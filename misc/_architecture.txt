bthome
	parse v1, v2
	parse payload

espnow


meshrc_bthome_over_espnow
bthome_over_espnow -- BTHoENW (project Beethowen)

beethowen
-- receiver sensor
		beethowen_receiver:
			
		sensor:
		  - platform: beethowen_receiver
			mac_address: 11:22:33:44:55:66
			name_prefix: Beethowen TestDevice
			sensors:
			  - measurement_type: temperature
				name: Temperature
	
void on(esp_rc_callback_t callback) {


0xD2, 0xFC, 0x80 <BTHOME> data packet
0xD2, 0xFD, 0x01 == find server
0xD2, 0xFD, 0x02 == server found (empty)

// upon packet arrival check and return (data+3) ptr
// check V2 header 2 bytes + sw_version 1 byte (adv_info) -- 0xD2, 0xFC, 0x80) --> ((0x80<<5&7) == 2 // 5-7 bits)
// max payload is 247 bytes
typedef std::function<void(uint8_t* data)> esp_rc_data_callback_t;
// after parsing
typedef std::function<void(uint8_t meas_typ, float value)> esp_rc_data_callback_t;
	
	
	
-- lib encoder
		bthomeencoder = new BTHomeEncoder()
		bthomeencoder->resetMeasurement()
		bthomeencoder->addMeasurement(0x02, 25.06);
		bthomeencoder->addMeasurement(0x03, 58.00);
		bthomeencoder->buildPaket()
		// bthomeencoder->m_sensorData
		
-- esphome encoder
		beethowen_transmitter: (all sending sensors are registered)
			persistent: true
			id: my_beethowen_transmitter
			proxied_sensors:
				- measurement_type: temperature
				  sensor_id: bmp085_temperature_sensor ## "implement sensor holder"
			auto_send: true 				# should check if all sensors have state // not outstanding reads then send it automatically
			
		
		sensor:
			- platform: beethowen_transmitter
				id: beethowen_testdevice_temperature
				name: Temperature
				measurement_type: temperature
				lambda: |-
					auto value = id(bmp085_temperature_sensor).state;
					return value;

			- platform: bmp085
				temperature:
					id: bmp085_temperature_sensor
					internal: true
					filters:
						- lambda: |-
						    id(my_beethowen_transmitter).register_reading(id(bmp085_temperature_sensor), 0x02, x)
		
		script:
		  - id: update_and_send_data
			lambda: |-
			  id(my_bmp085).update();
			  
			  // collects all sensors with data, assembles, then sends
			  global_beethowen_component->send();
			  
	BeethowenComponent::BeethowenComponent() { global_beethowen_component = this; }
	extern BeethowenComponent *global_beethowen_component;  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)

extern APIServer *global_api_server;  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)

-- Home Assistant parser integration
with service to send data / proxy data to
esp add beethowen "server" component option to proxy all incoming data to HA


-----------




- add channelid to found response
- add OTA_SWITCH to communication channel
	ota::OTAComponent *ota_;
	from esphome.components.ota import OTAComponent
	this->get_ota()->set_safe_mode_pending(true);
	
	// Enqueue message as this is called from a high priority wifi thread, and documentation says not to spend too long in here...
      proxy_message *message = (proxy_message *)malloc(sizeof(proxy_message));

      memcpy(message, incomingData, sizeof(proxy_message));
      proxy_message_incoming_queue_->push(message);

      // This seems to be needed to have ESPNow and WiFi working together
      proxy_base::ESPResultDecoder::check_esp_result_bool(WiFi.mode(WIFI_AP_STA), "WiFi.mode");
- 
    void ProxyTransmitterComponent::proxy_setup()
    {
      // This runs before wifi component starts up...
      get_wifi()->mark_failed(); // To kill it

      int channel = peer_receiver_->get_espnow_channel();

      ESP_ERROR_CHECK(esp_netif_init());
      ESP_ERROR_CHECK(esp_event_loop_create_default());
      wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
      ESP_ERROR_CHECK(esp_wifi_init(&cfg));
      ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
      ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
      ESP_ERROR_CHECK(esp_wifi_start());

      setup_espnow();

      peer_receiver_->espnow_add_peer();

      proxy_base::ESPResultDecoder::check_esp_result_code(esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE), "WiFi.channel");
    }
- OTA remote from URL?
- OTA remote mode with AP?
- transmitter_sensor:
	proxy_id: ?
	
		beethowen_receiver:

		sensor:
		  - platform: beethowen_receiver
			mac_address: 11:22:33:44:55:66
			passkey: 0xABCD 						# only accept measurement with this key
			name_prefix: Beethowen TestDevice
			sensors:
			  - measurement_type: temperature
				name: Temperature
		
		############

		ota:

		beethowen_transmitter:
			id: my_beethowen_transmitter
			proxied_sensors:	# sensors and binary_sensors
				- measurement_type: temperature
				  sensor_id: bmp085_temperature_sensor ## "implement sensor holder"
			auto_send: true 				# should check if all sensors have state // not outstanding reads then send it automatically
			auto_deepsleep: true			# capture deepsleep and call on all sensors read / do a read and send if not done before sleep!
			ota-ap:
				ssid: "$systemName"
				password: !secret wifi_password
			persistent: true
			

client->bcast:	0xD2FD, 0x01, 0xABCD 				== find server with passkey 0xABCD
server->client:	0xD2FD, 0x02, 0xABCD, 0x0B 			== server found or channel 11

server->client:	0xD2FD, 0x03, 0xABCD 				== start local OTA with pre-configured AP
server->client:	0xD2FD, 0x03, 0xABCD, URL/nullterm 	== start local OTA with pre-configured AP

client->server:	0xD2FD, 0xFF, 0x80, 0xABCD, <BTHomeData> == data packet

client->server:	0xD2FC, 0x80, 0xABCD, <BTHomeData>	== data packet

server->client:	0xD2FD, 0x00, 0xABCD				== request client system_info
client->server:	0xD2FD, 0x00, 0xABCD, 0x00 [system_version], 0x01 [v1], 0x01 [system_name], 0x10 [len=16], "beethowen_remote" == response system_info

//check: can I extend sensor.SENSOR_SCHEMA model with a field e.g. beethowen_measurement_type: temperature + modify def to_code? --? probably not

